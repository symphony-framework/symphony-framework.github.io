<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Symphony</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./stylesheets/styles.css" rel="stylesheet">
  </head>

  <body class="text-gray-600">

    <!-- Nav bar -->

    <header class="fixed top-0 left-0 w-full bg-white shadow-lg">
      <ul class="pb-8 flex flex-row w-full border-b h-full">
        <li class='ml-10 mr-auto'>Symphony logo</li>
        <li class='mx-10'>Our team</li>
        <li class='mx-10'>Presentation</li>
        <li class="mx-10">Docs</li>
        <li class='mx-10'>Github</li>
      </ul>
    </header>

    <div id="intro">

      <!-- First intro panel -->

      <div class="intro-panels">
        <div class="intro-panel">
          <!-- <img src="./images/6.png" alt="Symphony logo" class="w-10"/> -->
          <p class="text-5xl">Symphony logo</p>
        </div>
        <div class="intro-panel bg-symphony-background-blue text-gray-50">
          <p class="text-center w-1/2 text-5xl leading-relaxed">
            Symphony brings real-time collaboration to web applications
          </p>
        </div>
      </div>

      <!-- Second intro panel -->

      <div class="intro-panels">
        <div class="intro-panel bg-symphony-dark-green">
          <p class="text-5xl">More stuff here</p>
        </div>
        <div class="intro-panel bg-symphony-dark-green text-gray-50">
          <p class="text-center w-1/2 text-5xl leading-relaxed">
            Even more stuff
          </p>
        </div>
      </div>

      <!-- Third intro panel -->

      <div class="intro-panels">
        <div class="intro-panel bg-symphony-light-blue text-gray-50">
          <p class="text-5xl">Something else?</p>
        </div>
        <div class="intro-panel bg-symphony-light-blue">
          <p class="text-center w-1/2 text-5xl leading-relaxed">
            Pretty awesome stuff right here
          </p>
        </div>
      </div>
    
    </div>

    <!-- Sidebar -->
    
    <ul class="pl-12 pt-6 border-r fixed w-96 top-24 -left-96 transition-all" id="sidebar">
      <li class="sidebar-section" id="section-1-sidebar" data-section="1">
        <a href="#section-1">Introduction</a>
        <ul class="sidebar-subsection-list" data-section="1">
          <li class="sidebar-subsection" data-subsection="1.1">
            <a href="#subsection-1.1">Introducing Symphony</a>
          </li>
        </ul>
      </li>
      <li class="sidebar-section" id="section-2-sidebar" data-section="2">
        <a href="#section-2">What is real-time collaboration</a>
        <ul class="sidebar-subsection-list" data-section="2">
          <li class="sidebar-subsection" data-subsection="2.1">
            <a href="#subsection-2.1">Real-time</a>
          </li>
          <li class="sidebar-subsection" data-subsection="2.2">
            <a href="#subsection-2.2">Collaboration</a>
          </li>
        </ul>
      </li>
      <li class="sidebar-section" id="section-3-sidebar" data-section="3">
        <a href="#section-3">Solutions</a>
        <ul class="sidebar-subsection-list" data-section="3">
          <li class="sidebar-subsection" data-subsection="3.1">
            <a href="#subsection-3.1">Do-it-yourself (DIY)</a>
          </li>
          <li class="sidebar-subsection" data-subsection="3.2">
            <a href="#subsection-3.2">Real-time collaboration as a service</a>
          </li>
          <li class="sidebar-subsection" data-subsection="3.3">
            <a href="#subsection-3.3">Where does Symphony fit in?</a>
          </li>
        </ul>
      </li>
      <li class="sidebar-section" id="section-4-sidebar" data-section="4">
        <a href="#section-4">Using Symphony</a>
        <ul class="sidebar-subsection-list" data-section="4">
          <li class="sidebar-subsection" data-subsection="4.1">
            <a href="#subsection-4.1">Backend</a>
          </li>
          <li class="sidebar-subsection" data-subsection="4.2">
            <a href="#subsection-4.2">Client</a>
          </li>
          <li class="sidebar-subsection" data-subsection="4.3">
            <a href="#subsection-4.3">Developer dashboard</a>
          </li>
        </ul>
      </li>
    </ul>

    <!-- Case Study -->

    <div class='ml-96 pl-20 mr-64'>

      <!-- Section 1 -->

      <div id="section-1" class="pt-20">
        <h2 class='section-heading' data-section="1"></h2>
        <blockquote class='blockquote'>
          "Alone we can do so little; together we can do so much." <nobr>- Hellen Keller</nobr>
        </blockquote>
        <p class='casestudy-text'>
          Collaboration has been a key feature of the internet since its earliest days. The history of collaboration on the internet can be traced back to the 1960s, when Douglas Engelbart, the inventor of the computer mouse, studied how computers could support collaborative work and communication. He developed a system called NLS (oN-Line System) that allowed users to create and edit documents, link them together, and share them with others.
        </p>
        <p class='casestudy-text'>
          Of course, for much of the internet’s history, collaboration had to be done asynchronously - collaborators might email a document back and forth after each round of changes, for example.
        </p>
        <p class='casestudy-text'>
          Even today, many online editing tools do not allow for concurrent changes by multiple users in real-time. Basecamp, for example, is an online collaboration platform that allows users to share and work on the same documents. What happens, though, when more than one user wants to edit a document at the same time?
        </p>
        <div class="diagram">
          <img src="images/diagrams/lockedout.PNG"/>
        </div>   
        <p class="casestudy-text">
          As the above image shows, online collaboration via Basecamp is <strong>not real-time</strong>—only one user is allowed to modify content at a time, and others must wait for that user to finish before making their own changes.
        </p>
        <div class="diagram">
          <img src="images/diagrams/collab-apps.png"/>
        </div>
        <p class="casestudy-text">
          Some other well-known applications such as Figma, Google Docs, Miro, and Trello allow users to modify shared content at the same time—in other words, collaborate in <strong>real-time</strong>.
        </p>
        <p class="casestudy-text">
          <strong>Real-time collaboration</strong> refers to the ability for multiple users to work on the same document or project simultaneously and see the changes made by others as they happen. Real-time collaboration has become so prevalent that some deem it an essential aspect of many modern web applications, one that has opened up new ways of working together on the web.
        </p>
        <blockquote class="blockquote">"[Real-time collaboration] eliminates the need to export, sync, or email copies of files and allows more people to take part in the design process." <nobr>- Evan Wallace, Figma</nobr></blockquote>

        <div id="subsection-1.1">
          <h3 class="subsection-heading" data-subsection="1.1">Introducing Symphony</h3>
          <p class='casestudy-text'>
            <strong>Symphony</strong> is a platform for providing real-time collaboration to web applications.
          </p>
          <p class='casestudy-text'>
            What does that mean?
          </p>
          <p class='casestudy-text'>
            Let’s illustrate this with a simple whiteboard application that we’ve created for demo purposes. Users can perform the basic actions you’d expect in this kind of app, like drawing lines, adding shapes, changing colors, and so on. At this point, this is just a single-user application that does not support multi-user collaboration.
          </p>
          <p class='casestudy-text'>
            Go ahead, give it a try.
          </p>
          <p class="casestudy-text font-bold">[TBA - single whiteboard app]</p>
          <p class='casestudy-text'>
            Now let’s add Symphony into the mix. By deploying the Symphony backend to AWS and connecting it with our whiteboard by adding a few lines of code, the application is now collaborative. Users can work together in the same collaborative space and see what others are doing in real-time.
          </p>
          <p class='casestudy-text'>
            Try and see what happens when you draw on either of the below whiteboards.
          </p>
          <p class='casestudy-text font-bold'>
            [TBA - whiteboard apps side by side]
          </p>
          <p class='casestudy-text'>
            In this case study, we will explore the components of web-based real-time collaboration, review existing solutions that can enable real-time collaboration in applications, and present our project, Symphony: how developers can use it, how we created it, and the trade-offs we weighed during the development process.
          </p>
        </div>

      <!-- Section 2 -->

      <div id="section-2" class="pt-20">
        <h2 class='section-heading' data-section="2">What is real-time collaboration?</h2>
        <div id="subsection-2.1">
          <h3 class="subsection-heading" data-subsection="2.1">Real-time</h3>
          <p class='casestudy-text'>
            For an application to feature real-time collaboration, the first requirement is that data must be exchanged between users, or between users and a server, in real-time. Generally, when we say that an application is “real-time”, we mean that the user sees updated data either instantly or without noticeable delay, and without needing to take any specific action or make any particular request to see the updated data.
          </p>
          <div class="diagram">
            <img src="images/diagrams/real-time-example.gif"/>
          </div>
          <p class='casestudy-text'>
            For the purposes of real-time collaboration, data must flow in two directions: from the user, when that user makes a change that will be shared with others, and to the user, when someone else makes a change.
          </p>
          <div class="diagram">
            <img src="images/diagrams/broadcast.gif"/>
          </div>
          <p class='casestudy-text'>
            When implementing a real-time web application, challenges arise because HTTP, the protocol by which most web communication occurs, is not real-time by design. Instead, HTTP uses a request-response model whereby the client sends a request to a server and then waits for the server to respond with the requested data.
          </p>
          <div class="diagram">
            <img src="images/diagrams/http-request-response.png"/>
          </div>
          <p class="casestudy-text">
            So how can we make an application that lets users see a constant stream of updated data? For bi-direction, real-time data exchange over the web, two protocols in particular merit our consideration: <strong>WebRTC</strong> and <strong>WebSocket</strong>.
          </p>
        </div>
        <h4 class="subsubsection-heading">WebRTC</h4>
        <p class="casestudy-text">
          <strong>WebRTC</strong>, which stands for Web Real-Time Communication, is an open-source project that allows web browsers and mobile applications to engage in peer-to-peer real-time communication via APIs. The connection between peers is established with the use of a signaling server that acts as an initial intermediary, allowing two clients to find each other and negotiate connection parameters. Once the connection is established, data is transferred directly between the peers via media streams and/or data channels.
        </p>
        <div class="diagram">
          <img src="images/diagrams/WebRTC.gif"/>
        </div>
        <p class="casestudy-text">
          Since WebRTC is primarily used over UDP, it offers superior latency at the cost of some packet loss. This makes it an especially attractive choice for video and audio streaming.
        </p>
        <h4 class="subsubsection-heading">WebSocket</h4>
        <p class="casestudy-text">
          <strong>WebSocket</strong> is a protocol that provides a two-way channel of real-time communication between a client and a server. The connection is established via the WebSocket handshake: 
        </p>
        <ul class="casestudy-list">
          <li class="casestudy-list-item">
            The client sends an HTTP request to the server with an <code>Upgrade</code> header
          </li>
          <li class="casestudy-list-item">
            The server responds with <code>Connection: Upgrade</code> and <code>Upgrade: Websocket</code> headers
          </li>
        </ul>
        <p class="casestudy-text">
          Once the handshake is complete, the WebSocket connection is established using the same underlying TCP/IP connection used in the handshake, and either party can now send data.
        </p>
        <div class="diagram">
          <img src="images/diagrams/WebSocket.gif"/>
        </div>
        <p class="casestudy-text">
          WebSocket provides better data integrity than WebRTC due to the underlying reliability of TCP. It is therefore often used in situations where delivering accurate data is paramount (e.g. real-time dashboards, stock price tickers) and where minimizing latency is less critical (e.g. live chat).
        </p>
        <h4 class="subsubsection-heading">
          Real-time infrastructure in Symphony
        </h4>
        <p class="casestudy-text">
          As we have seen, both WebRTC and WebSocket have trade-offs that make each better for some use cases and less suitable for others. When designing Symphony, we thought about which of these two technologies would be better for our use case. 
        </p>
        <p class="casestudy-text">
          Applications that would use Symphony are likely already using a client-server model. We also knew that we wanted to persist data - both the data users are working on, as well as metadata about how users are collaborating. To do this, a server would be needed. As a protocol based on a client-server model, WebSocket was therefore a natural choice for us.
        </p>     

        <div id="subsection-2.2">
          <h3 class="subsection-heading" data-subsection="2.2">Collaboration</h3>
          <p class='casestudy-text'>
            Now that we’ve established what “real-time” means and how it can be achieved over the web, let’s turn to collaboration. What do we mean by “collaboration,” and what are some of its components?
          </p>
          <p class='casestudy-text'>
            First, let’s consider a simple chat application. Imagine we have two users, Sarah and Bob, exchanging messages in real-time. As soon as one user enters a message, the other user sees the message displayed without noticeable delay. Is this an example of a collaborative application?
          </p>
          <div class="diagram">
            <img src="images/diagrams/chat-app.gif"/>
          </div>
          <p class='casestudy-text'>
            The answer is <strong>no</strong>. While the two users are exchanging information in real-time, they are not collaborating because they are not modifying the same state. Each user has control only over his or her own messages, and each of these messages is independent of the others. Sarah can see Bob’s messages in real-time, but she cannot modify them.
          </p>
          <p class="casestudy-text">
            Now let’s look at a different kind of application. 
          </p>
          <div class="diagram">
            <img src="images/diagrams/word-processor.gif"/>
          </div>
          <p class="casestudy-text">
            This time, Sarah and Bob are using an online word processor to work together on a document. Sarah and Bob are each making their own changes, but they are viewing the same document, reflecting the modifications made by both users to that document, in real-time. Therefore we can say that there exists a <strong>shared state</strong> between Sarah and Bob.
          </p>
          <p class="casestudy-text">
            This shared state, which is reflected in a single synchronized view presented to all users working on the same document or project, lies at the core of real-time collaborative applications.
          </p>
          <p class="casestudy-text">
            Let’s now review some concepts that are critical to understanding how online collaboration works.
          </p>
          <h4 class="subsubsection-heading">Conflict</h4>
          <p class="casestudy-text">
            In a chat application, delayed or out-of-order delivery of messages is generally not a critical problem.
          </p>
          <div class="diagram">
            <img src="images/diagrams/chat-app-conflict.gif"/>
          </div>
          <p class="casestudy-text">
            Turning back to Sarah and Bob’s document, though, what happens if Sarah makes some changes, but due to network conditions these updates are delivered to Bob out of order?
          </p>
          <div class="diagram">
            <img src="images/diagrams/word-processor-out-of-order.gif"/>
          </div>
          <p class="casestudy-text">
            Here, Sarah makes two changes to the title, but due to network conditions the changes are delivered to Bob in reverse order. Bob’s state now reflects the first change, while Sarah’s state reflects the second. This means that Sarah and Bob are out of sync, and we’ve lost the critical underpinning of real-time collaboration - a shared state.
          </p>
          <p class="casestudy-text">
            Now let’s imagine that Sarah and Bob make different changes to the same content at the same time. What might happen then?
          </p>
          <div class="diagram">
            <img src="images/diagrams/word-processor-out-of-order-same-time.gif"/>
          </div>
          <p class="casestudy-text">
            Here, Sarah and Bob have different ideas for what a good title would be, and they each transmit a change to the title at the same time. Next, Bob’s change is delivered to Sarah, which overrides the state presented in her client–she now sees Bob’s version. Meanwhile, Sarah’s change is delivered to Bob, which overrides his local state, and he is now shown Sarah’s version. Again, the users find themselves out of sync.
          </p>
          <p class="casestudy-text">
            It’s acceptable - even inevitable - for users to go out of sync temporarily, but we need some way of ensuring that they will eventually converge again to the same state. In the end, we want all users to see the same document on their screen, reflecting all the changes that have been made
          </p>
          <p class="casestudy-text">
            So how can we deal with conflicting changes made by different users? There are generally two families of algorithms that are used for this.
          </p>
          <h5 class="mini-heading">Operational transformation</h5>
          <p class="casestudy-text">
            <strong>Operational transformation (OT)</strong> is the traditional technique to synchronize and reconcile concurrent changes to a shared data structure in real-time collaborative applications. When a user inserts or deletes data, that change is first sent to the server. The server then modifies, or transforms, that change if necessary, before sending it on to other users.
          </p>
          <p class="casestudy-text">
            Used most famously by Google Docs, OTs are especially good for text editing of long documents with low memory and performance overhead. They do have downsides, however. They generally require that a user be connected to the server at all times, limiting the user’s ability to work offline and sync up later after connecting. Most importantly, they are very hard to implement correctly. It is difficult to deal with all edge cases, and many papers on OT implementations were found to have errors, years after publication. 
          </p>
          <blockquote class="blockquote">
            "Unfortunately, implementing OT sucks. There's a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly." <nobr>- Joseph Gentle, Google Wave engineer</nobr>
          </blockquote>
          <h5 class="mini-heading">Conflict-free replicated data types</h5>
          <p class="casestudy-text">
            A <strong>conflict-free replicated data type (CRDT)</strong> is a type of data structure that is designed to be replicated across multiple devices while ensuring that all replicas converge to the same state, even in the presence of concurrent updates. 
          </p>
          <p class="casestudy-text">
            A relatively new concept aiming to solve problems in distributed computing, CRDTs have become a popular choice in resolving merge conflicts arising out of real-time collaboration, which can be seen as a kind of distributed system where state is shared across multiple clients.
          </p>
          <p class="casestudy-text">
            Unlike OT, CRDTs do not make any assumptions about your network topology–they can be used in a strictly peer-to-peer environment, but also work perfectly well in a client-server model.
          </p>
          <blockquote class="blockquote">
            "Even if you have a client-server setup, CRDTs are still worth researching because they provide a well-studied, solid foundation to start with."" <nobr>- Evan Wallace, Figma</nobr>
          </blockquote>
          <p class="casestudy-text">
            Early CRDTs were found to be relatively slow compared to their OT counterparts. Another potential downside is memory overhead, since every change to a document creates more data that must be retained to guarantee consistency.
          </p>
          <blockquote class="blockquote">
            "Because of how CRDTs work, documents grow without bound. … Can you ever delete that data? Probably not. And that data can’t just sit on disk. It needs to be loaded into memory to handle edits." <nobr>- Joseph Gentle</nobr>
          </blockquote>
          <p class="casestudy-text">
            Recent work by Martin Kleppmann and others has made CRDTs faster and less memory hungry. These advancements have led CRDTs to overtake OT as the tool of choice for real-time collaboration in the estimation of some researchers.
          </p>
          <div class="diagram">
            <img src="images/diagrams/automerge-yjs.png"/>
          </div>
          <h5 class="mini-heading">Conflict resolution in Symphony</h5>
          <p class="casestudy-text">
            So which choice is best?
          </p>
          <p class="casestudy-text">
            The first thing to point out is that there is no single best, one-size-fits-all solution to resolving merge conflicts. The best choice will, therefore, depend on the specific use case.
          </p>
          <p class="casestudy-text">
            For Symphony, we were looking for something that was open-source, well-documented, and performant. For that reason, we chose <strong>Yjs</strong>, as it is a mature CRDT implementation with an active community and tools ecosystem. Yjs has also has been battle-tested in production applications including:            
          </p>
          <ul class="casestudy-list">
            <li class="casestudy-list-item">
              Room.sh, meeting spaces with collaborative drawing, editing, and coding
            </li>
            <li class="casestudy-list-item">
              Nimbus Note, team collaboration software
            </li>
            <li class="casestudy-list-item">
              Dynaboard, a tool for collaborative web development
            </li>
          </ul>
          <p class="casestudy-text">
            We also considered using Automerge, the other leading open-source offering in this space. There was probably not a wrong choice to be made between the two, but we were ultimately persuaded by Yjs’s superior maturity and speed, as well as its relative memory efficiency.
          </p>
          <h4 class="subsubsection-heading">Rooms</h4>
          <div class="diagram">
            <img src="images/diagrams/rooms.png"/>
          </div>
          <p class="casestudy-text">
            Collaboration is something that happens when two or more users work together on a specific document or project. We call this group of collaborating users, together with the shared state they are collaborating on, a <strong>room</strong>. This is consistent with the nomenclature favored by others in this space including Liveblocks, a provider of real-time collaboration as a service:
          </p>
          <blockquote class="blockquote">
            "A room is the space people can join to collaborate together."" <nobr>- Liveblocks</nobr>
          </blockquote>
          <p class="casestudy-text">
            A <strong>document</strong> is the shared state that users are collaborating on. Keep in mind that collaboration is <strong>not limited to text documents</strong>; a document could also be a JavaScript Map with key/value pairs that represent drawn objects on a whiteboard, for example.
          </p>
          <h4 class="subsubsection-heading">Presence</h4>
          <p class="casestudy-text">
            When collaborating with others, it is useful to see not only the current state of the document but also which users are currently present and what they are doing at any given moment. Seeing what other users are doing in real-time makes for a smoother and more meaningful collaborative experience.
          </p>
          <div class="diagram">
            <img src="images/diagrams/whiteboard-awareness.png"/>
          </div>
          <p class="casestudy-text">
            We call this feature <strong>presence</strong>, which is the term most commonly used by other providers of real-time collaboration tools, including Liveblocks.
          </p>
          <p class="casestudy-text">
            In Symphony, presence is implemented using the Yjs Awareness Protocol. Each client sends an update to the server when some aspect of presence–cursor position for example– has changed. Which data to include in these presence updates, and the way that data is structured, is left to the application developer.
          </p>
          <p class="casestudy-text">
            It should be noted that presence data is distinct from the shared state (document) that is the subject of users’ collaboration. Importantly, presence data is ephemeral and does not need to be retained on the backend.
          </p>
          <h4 class="subsubsection-heading">Undo/Redo</h4>
          <p class="casestudy-text">
            There is one additional concept worth discussing when it comes to collaborative applications: the ability of users to <strong>undo</strong> (and/or <strong>redo</strong>) their updates.
          </p>
          <p class="casestudy-text">
            When only a single user is editing, the concept of undo is simple: simply revert to the state immediately preceding the most recent change.
          </p>
          <div class="diagram">
            <img src="images/diagrams/whiteboard-undo.gif"/>
          </div>
          <p class="casestudy-text">
            However, when multiple users are making changes, the picture gets more complicated. If a user’s undo action simply returns the state to that immediately preceding that user’s last update, what happens to intervening updates by others?
          </p>
          <div class="diagram">
            <img src="images/diagrams/whiteboard-undo-collab.gif"/>
          </div>
          <p class="casestudy-text">
            When Bob clicks the undo button, Alice’s red triangle is deleted. That’s probably not what either person wanted!
          </p>
          <p class="casestudy-text">
            So going back to the state preceding the user’s change is not the answer. What we want instead is to make the undo/redo behavior user-specific. Fortunately, Yjs provides us with a robust undo/redo implementation that does just that: it limits the scope of these actions to the user’s own changes.
          </p>
          <div class="diagram">
            <img src="images/diagrams/whiteboard-undo-collab-good.gif"/>
          </div>
          <p class="casestudy-text">
            When Bob clicks “Undo”, his color change to the circle is reverted, but Alice’s red triangle remains in place.
          </p>
        </div>

      <!-- Section 3 -->

      <div id="section-3" class="pt-20">
        <h2 class='section-heading' data-section="3">Solutions</h2>
        <p class='casestudy-text'>
          Now that we understand the ingredients of real-time collaboration, let’s place ourselves in the shoes of a developer who wishes to add real-time collaboration to an application. What kinds of functionality and infrastructure will we need?
        </p>
        <p class='casestudy-text'>
          First, we’ll want a WebSocket server or servers to receive updates from users and transmit those updates to other users who are in the same room.
        </p>
        <p class='casestudy-text'>
          Next, we’ll need a means of resolving merge conflicts, e.g. an implementation of OT or a CRDT.
        </p>
        <div class="diagram">
          <img src="images/diagrams/real-time-banner.png"/>
        </div>
        <p class='casestudy-text'>
          Ideally, we will also have a way of persisting room state. When users leave a room, they probably don’t want to lose all of their work. Instead, they should be able to return later and pick up where they left off. This can be achieved by storing room state in a database when users disconnect, and retrieving that state from the database when they reconnect.
        </p>
        <p class='casestudy-text'>
          What if a user loses their internet connection but wants to continue working on a document? Wouldn’t it be nice if a user’s offline changes can be stored and then synced back up with others when the user reconnects? To enable this, we’ll want a way for each client to store state locally.
        </p>
        <p class='casestudy-text'>
          Finally, from the developer’s perspective, it could be useful to know how users are collaborating in an application. A developer dashboard might be one way of gaining visibility into metrics like the number of rooms, the number of users per room, and the size of the document associated with a given room.
        </p>
        <p class="casestudy-text">
          What then are the developer’s options for obtaining this functionality and related infrastructure?
        </p>

        <div id="subsection-3.1">
          <h3 class="subsection-heading" data-subsection="3.1">Do-it-yourself (DIY)</h3>
          <p class='casestudy-text'>
            One option is for the developer to implement or source each of these components separately and stitch them together.
          </p>
          <p class='casestudy-text'>
            For the backend infrastructure to handle real-time messaging and persist state, one could use a so-called backend-as-a-service such as Ably, Pusher, or PubNub, or alternatively deploy one’s own backend by provisioning resources on a cloud provider like AWS.
          </p>
          <p class='casestudy-text'>
            For conflict resolution, as we discussed earlier, robust open-source solutions such as Yjs and Automerge are a solid choice. One could even choose to implement a bespoke conflict resolution implementation, although this would be considerably more time-consuming and difficult.
          </p>
          <p class="casestudy-text">
            In sum, going the DIY route is less costly, but the implementation burden placed on the developer is higher.
          </p>
        </div>

        <div id="subsection-3.2">
          <h3 class="subsection-heading" data-subsection="3.2">Real-time collaboration as a service</h3>
          <p class='casestudy-text'>
            Building out your own backend to manage websocket connections and implementing or integrating a means of conflict resolution can be challenging. For this reason, services and frameworks exist to abstract away the backend and conflict resolution and let the developer focus on their application itself.
          </p>
          <blockquote class="blockquote">
            "Because building low-latency, collaborative experiences is hard!" <nobr>- Microsoft</nobr>
          </blockquote>
          <h4 class="subsubsection-heading">Liveblocks</h4>
          <p class="casestudy-text">
            Liveblocks is a major player in this space that provides an all-in-one solution for developers wishing to add real-time collaboration to their applications. A service that takes care of managing and scaling the WebSocket infrastructure, Liveblocks also provides a custom CRDT-like solution for resolving merge conflicts. This convenience comes at a cost, however: for an application with up to 2,000 monthly active users, the price is $299 as of this writing.
          </p>
          <h4 class="subsubsection-heading">Fluid Framework</h4>
          <p class="casestudy-text">
            Fluid Framework is an open-source, cloud-agnostic framework for real-time collaboration, developed by Microsoft. For conflict resolution, it uses a distributed data structure that Microsoft describes as “more similar to CRDT than OT.” When deployed on a single server, Fluid Framework can handle hundreds of concurrent users. For larger applications, however,the developer will need to implement her own scaling solution. Another drawback of Fluid Framework is that it does not include support for offline editing, although short periods of client disconnection are tolerated.
          </p>
          <p class="casestudy-text">
            While Fluid Framework itself is open-source and self-hosted, Microsoft also offers a managed service called Azure Fluid Framework that uses Fluid Framework under the hood.
          </p>         
        </div>

        <div id="subsection-3.3">
          <h3 class="subsection-heading" data-subsection="3.3">Where does Symphony fit in?</h3>
          <p class='casestudy-text'>
            We drew inspiration from both Liveblocks and Fluid Framework. Our goal was to build a framework that developers can easily integrate into existing applications to add real-time collaborative functionality. We also wanted Symphony to be open-source, like Fluid Framework, and to enable offline editing functionality.
          </p>
          <p class='casestudy-text'>
            We liked Liveblocks’ developer dashboard, which gives devs real-time insight into how users are collaborating via their application, and decided to implement a dashboard in Symphony as well.
          </p>
          <p class='casestudy-text'>
            In short, Symphony is aimed at developers of collaborative web applications who want to get real-time collaboration up and running quickly on a smaller budget.
          </p>
          <div class="diagram">
            <img src="images/diagrams/solutions.png"/>
          </div>
        </div>
      </div>

      <div id="section-4" class="pt-20">
        <h2 class='section-heading' data-section="4">Using Symphony</h2>
        <div class="casestudy-text">
          Symphony has three main components:
        </div>
        <ul class="casestudy-list">
          <li class="casestudy-list-item">
            Symphony backend
          </li>
          <li class="casestudy-list-item">
            Symphony client
          </li>
          <li class="casestudy-list-item">
            Symphony dashboard
          </li>
        </ul>
        <p class="casestudy-text">
          The Symphony backend receives updates from and distributes updates to clients via WebSocket connections, persists document data, and stores metadata about rooms and user connections to rooms.
        </p>
        <p class="casestudy-text">
          The Symphony client enables the developer’s web application to connect to, and exchange updates with, the Symphony backend.
        </p>
        <p class="casestudy-text">
          The Symphony dashboard provides developers with visibility into how their users are collaborating by displaying metadata about rooms and users.
        </p>

        <div id="subsection-4.1">
          <h3 class="subsection-heading" data-subsection="4.1">Backend</h3>
          <p class="casestudy-text">
            The first step to using Symphony is to deploy the Symphony backend to AWS.
          </p>
          <p class="casestudy-text font-bold">
            [TBA]
          </p>
        </div>
        <div id="subsection-4.2">
          <h3 class="subsection-heading" data-subsection="4.2">Client</h3>
          <p class="casestudy-text">
            Once you’ve got the Symphony backend deployed, the next step is to import the Symphony client into your web application.
          </p>
          <p class="casestudy-text">
            First, install the <code>@symphony-rtc/client</code> npm library:
          </p>          
          <code class="code-example">
            $ npm install @symphony-rtc/client<br>
          </code>
          <p class="casestudy-text">
            Next, in your application, import the <code>SymphonyClient</code> class and instantiate a new client object, passing in your Symphony backend endpoint:
          </p>
          <code class="code-example">
            import { SymphonyClient } from "@symphony-rtc/client";<br>
            <br>
            const client = new SymphonyClient(websocket_url);
          </code>
          <div class="casestudy-text">
            To begin collaborating, call enter on the client object, passing in the name of the room (<code>roomId</code>) as an argument:
          </div>
          <code class="code-example">
            const room = client.enter(roomId);
          </code>
          <div class="casestudy-text">
            Symphony provides two shared data types for collaboration: <code>SyncedMap</code>, an object based on the JavaScript Map, and <code>SyncedList</code>, which is based on the JavaScript Array. To create one of these data types, call the appropriate method on the room object returned in the previous step, e.g:
          </div>
          <code class="code-example">
            const syncedMap = room.newMap();
          </code>
          <div class="casestudy-text">
            To subscribe to updates to a synced data structure, call <code>subscribe</code> on the room object, passing in the synced object and a callback function. The callback function will be invoked when the synced data structure is updated.
          </div>
          <code class="code-example">
            room.subscribe(syncedMap, event => {<br>
              &#160;&#160;// ...<br>
            })
          </code>
          <div class="casestudy-text">
            To stop collaborating in a room, call <code>leave</code> on the client object and pass in the name of the room (<code>roomId</code>) as an argument:
          </div>
          <code class="code-example">
            client.leave(roomId);
          </code>
          <p class="casestudy-text">
            The Symphony client is designed with ease of use in mind, abstracting away some of the complexity of working with the underlying Yjs types. If you want more granular, low-level control, or access to Yjs types not implemented in Symphony such as Text, XmlElement, XmlFragment, etc., you can still use the Yjs API on the frontend–it works just fine with the Symphony backend. For more information about the Yjs API, see the <a href="https://docs.yjs.dev/" class="casestudy-link">Yjs documentation</a>.
          </p>
        </div>

        <div id="subsection-4.3">
          <h3 class="subsection-heading" data-subsection="4.3">Developer dashboard</h3>
          <p class="casestudy-text">
            With the Symphony backend up and running and the Symphony client integrated in your application, your users can now collaborate.
          </p>
          <p class="casestudy-text">
            But for the developer, the story doesn’t end there.
          </p>
          <p class="casestudy-text font-bold">
            [TBA]
          </p>
        </div>
      </div>

      <div id="section-5" class="pt-20">
        <h2 class="section-heading" data-section="5">Building Symphony</h2>
        <div id="subsection-5.1">
          <h3 class="subsection-heading" data-subsection="5.1">Design philosophy</h3>
        </div>
      </div>
    </div>


    <script src="javascripts/index.js"></script>
  </body>
</html>